import{_ as i,D as l,c as r,I as n,w as a,a4 as s,j as e,a as t,o as c}from"./chunks/framework.DtvhUNIn.js";const h="/assets/CH-UN14.JdfPdlbJ.jpg",X=JSON.parse('{"title":"Chap14. COMPONENT COUPLING 组件耦合","description":"","frontmatter":{},"headers":[],"relativePath":"books/cleanArch/ch14.md","filePath":"books/cleanArch/ch14.md","lastUpdated":1723198909000}'),d={name:"books/cleanArch/ch14.md"},p=s("",34),u=s("",15),m=s("",11),b=e("ol",{start:"2"},[e("li",null,"Create a new component that both Entities and Authorizer depend on. Move the class(es) that they both depend on into that new component (Figure 14.4).")],-1),f=e("blockquote",null,[e("ol",{start:"2"},[e("li",null,"创建一个新的组件，并让 Entities 与 Authorize 这两个组件都依赖于它。将现有的这两个组件中互相依赖的类全部放入新组件（如图 14.4 所示）。")])],-1),y=s("",36),g=e("p",null,"Figure 14.6 shows Y, which is a very unstable component. No other components depend on Y, so we say that it is irresponsible. Y also has three components that it depends on, so changes may come from three external sources. We say that Y is dependent.",-1),w=e("blockquote",null,[e("p",null,"下面再来看看图 14.6 中的 Y 组件，这是一个非常不稳定的组件。由于没有其他的组件依赖 Y，所以 Y 并不对任何组件负责。但因为 Y 同时依赖于三个组件，所以它的变更就可能由三个不同的源产生。这里就说 Y 是有依赖性的组件。")],-1),k=s("",8),T=s("",15),q=e("p",null,"The diagram in Figure 14.9 shows how the SDP can be violated.",-1),v=e("blockquote",null,[e("p",null,"下面再通过图 14.9 来看看违反 SDP 的情况：")],-1),I=e("p",null,"Flexible is a component that we have designed to be easy to change. We want Flexible to be unstable. However, some developer, working in the component named Stable, has hung a dependency on Flexible. This violates the SDP because the I metric for Stable is much smaller than the I metric for Flexible. As a result, Flexible will no longer be easy to change. A change to Flexible will force us to deal with Stable and all its dependents.",-1),_=e("blockquote",null,[e("p",null,"在图 14.9 中，Flexible 是在设计中要确保其易于变更的组件，因此我们会希望 Flexible 是不稳定的。然而，Stable 组件的开发人员却引入了对 Flexible 组件的依赖。这种情况就违反了 SDP，因为 Stable 组件的 I 指标要远小于 Flexible 的 I 指标。这将导致 Flexible 组件的变更难度大大增加，因为对 Flexible 组件的任何修改都必须要考虑 Stable 组件及该组件自身存在的依赖关系。")],-1),E=e("p",null,"To fix this problem, we somehow have to break the dependence of Stable on Flexible. Why does this dependency exist? Let’s assume that there is a class C within Flexible that another class U within Stable needs to use (Figure 14.10).",-1),A=e("blockquote",null,[e("p",null,"如果想要修复这个问题，就必须要将 stable 与 Flexible 这两个组件之间的依赖关系打破。为此，我们就需要了解这个依赖关系到底为什么会存在，这里假设是因为 Stable 组件中的某个类 U 需要使用 Flexible 组件中的一个类 C，如图 14.10 所示：")],-1),P=e("p",null,"We can fix this by employing the DIP. We create an interface class called US and put it in a component named UServer. We make sure that this interface declares all the methods that U needs to use. We then make C implement this interface as shown in Figure 14.11. This breaks the dependency of Stable on Flexible, and forces both components to depend on UServer. UServer is very stable (I = 0), and Flexible retains its necessary instability (I = 1). All the dependencies now flow in the direction of decreasing I.",-1),S=e("blockquote",null,[e("p",null,"我们可以利用 DIP 来修复这个问题。具体来说就是创造一个 UServer 组件，并在其中设置一个 US 接口类。然后，确保这个接口类中包含了所有 U 需要使用的函数，再让 C 实现这个接口，如图 14.11 所示。这样一来，我们就将从 Stable 到 Flexible 的这条依赖关系打破了，强迫这两个组件都依赖于 UServer。现在，UServer 组件会是非常稳定的（I=0），而 Flexible 组件则会依然保持不稳定的状态（I=1），结构图中所有的依赖关系都流向 I 递减的方向了。")],-1),C=s("",33),N=e("p",null,"Not all components fall into one of these two positions, because components often have degrees of abstraction and stability. For example, it is very common for one abstract class to derive from another abstract class. The derivative is an abstraction that has a dependency. Thus, though it is maximally abstract, it will not be maximally stable. Its dependency will decrease its stability.",-1),x=e("blockquote",null,[e("p",null,"当然，不可能所有的组件都能处于这两个位置上，因为组件通常都有各自的稳定程度和抽象化程度。例如一个抽象类有时会衍生于另一个抽象类，这种情况是很常见的，而这个衍生过程就意味着某种依赖关系的产生。因此，虽然该组件是全抽象的，但它并不是完全稳定的，上述依赖关系降低了它的稳定程度。")],-1),D=e("p",null,"Since we cannot enforce a rule that all components sit at either (0, 1) or (1, 0), we must assume that there is a locus of points on the A/I graph that defines reasonable positions for components. We can infer what that locus is by finding the areas where components should not be—in other words, by determining the zones of exclusion (Figure 14.13).",-1),F=e("blockquote",null,[e("p",null,"既然不能强制要求所有的组件都处于(0,1)和(1,0)这两个位置上，那么就必须假设 A/I 图上存在着一个合理组件的区间。而这个区间应该可以通过排除法推导出来，也就是说，我们可以先找出那些组件不应该处于的位置（请参考图 14.13）：")],-1),O=s("",34),L=e("p",null,"Another way to use the metrics is to plot the D metric of each component over time. The graph in Figure 14.15 is a mock-up of such a plot. You can see that some strange dependencies have been creeping into the Payroll component over the last few releases. The plot shows a control threshold at D = 0.1. The R2.1 point has exceeded this control limit, so it would be worth our while to find out why this component is so far from the main sequence.",-1),U=e("blockquote",null,[e("p",null,"D 指标的另外一种用法是按时间来跟踪每个组件的值，下面用图 14.15 来做一个示范。在该图中可以看到，Payroll 组件在最近几次发布中累积了一些意外的对外依赖。图中的 Q=0.1 是组件的达标红线，R2.1 这个值已经超出了红线范围，这就告诉我们现在值得花一些精力来找出这个组件偏离主序列线的原因了。")],-1),H=e("h2",{id:"conclusion-本章小结",tabindex:"-1"},[t("CONCLUSION 本章小结 "),e("a",{class:"header-anchor",href:"#conclusion-本章小结","aria-label":'Permalink to "CONCLUSION 本章小结"'},"​")],-1),R=e("p",null,"The dependency management metrics described in this chapter measure the conformance of a design to a pattern of dependency and abstraction that I think is a “good” pattern. Experience has shown that certain dependencies are good and others are bad. This pattern reflects that experience. However, a metric is not a god; it is merely a measurement against an arbitrary standard. These metrics are imperfect, at best, but it is my hope that you find them useful.",-1),W=e("blockquote",null,[e("p",null,"本章介绍了各种可用于依赖关系管理的指标，它们可以被用来里化分析某个系统设计与“优秀”设计模式之间的契合度。根据以往的经验，组件之间有些依赖关系是好的，有些依赖关系则是不好的，这些经验最后都会体现在这个设计模式中。当然，指标并不等同于真理，它只是对我们所定义标准的一个衡量。这些指标肯定是不完美的，但是我希望它们对读者有价值。")],-1);function M(z,Y,B,G,V,j){const o=l("Figures");return c(),r("div",null,[p,n(o,{figure:"14-1"},{default:a(()=>[t("Typical component diagram")]),_:1}),u,n(o,{figure:"14-2"},{default:a(()=>[t("A dependency cycle")]),_:1}),m,n(o,{figure:"14-3"},{default:a(()=>[t("Inverting the dependency between Entities and Authorizer")]),_:1}),b,f,n(o,{figure:"14-4"},{default:a(()=>[t("The new component that both Entities and Authorizer depend on")]),_:1}),y,n(o,{figure:"14-5"},{default:a(()=>[t("X: a stable component")]),_:1}),g,w,n(o,{figure:"14-6"},{default:a(()=>[t("Y: a very unstable component")]),_:1}),k,n(o,{figure:"14-7"},{default:a(()=>[t("Our example")]),_:1}),T,n(o,{figure:"14-8"},{default:a(()=>[t("An ideal configuration for a system with three components")]),_:1}),q,v,n(o,{figure:"14-9"},{default:a(()=>[t("SDP violation")]),_:1}),I,_,E,A,n(o,{figure:"14-10"},{default:a(()=>[t("U within Stable uses C within Flexible")]),_:1}),P,S,n(o,{figure:"14-11"},{default:a(()=>[t("C implements the interface class US")]),_:1}),C,n(o,{figure:"14-12"},{default:a(()=>[t("The I/A graph")]),_:1}),N,x,D,F,n(o,{figure:"14-13"},{default:a(()=>[t("Zones of exclusion")]),_:1}),O,n(o,{figure:"14-14"},{default:a(()=>[t("Scatterplot of the components")]),_:1}),L,U,n(o,{figure:"14-15"},{default:a(()=>[t("Plot of D for a single component over time")]),_:1}),H,R,W])}const J=i(d,[["render",M]]);export{X as __pageData,J as default};
