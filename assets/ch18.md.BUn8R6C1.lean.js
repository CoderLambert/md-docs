import{_ as i}from"./chunks/CH-UN18.mtki70hr.js";import{_ as l,D as r,c,I as a,w as n,a4 as s,j as e,a as o,o as h}from"./chunks/framework.DtvhUNIn.js";const N=JSON.parse('{"title":"Chap18. BOUNDARY ANATOMY 边界剖析","description":"","frontmatter":{},"headers":[],"relativePath":"ch18.md","filePath":"ch18.md","lastUpdated":1723191287000}'),p={name:"ch18.md"},d=s("",22),m=e("p",null,"When a high-level client needs to invoke a lower-level service, dynamic polymorphism is used to invert the dependency against the flow of control. The runtime dependency opposes the compile-time dependency.",-1),u=e("blockquote",null,[e("p",null,"但当高层组件中的客户端需要调用低层组件中的服务时，我们就需要运用动态形式的多态来反转依赖关系了。在这种情况下，系统在运行时的依赖关系与编译时的依赖关系就是相反的。")],-1),b=e("p",null,"In Figure 18.2, the flow of control crosses the boundary from left to right as before. The high-level Client calls the f() function of the lower-level ServiceImpl through the Service interface. Note, however, that all dependencies cross the boundary from right to left toward the higher-level component. Note, also, that the definition of the data structure is on the calling side of the boundary.",-1),y=e("blockquote",null,[e("p",null,[o("在图 18.2 中，控制流跨越边界的方向与之前是一样的，都是从左至右的。这里是高层组件 Client 通过 Service 接口调用了低层组件 Servicelmpl 上的函数 "),e("code",null,"f()"),o("。但请读者注意，图 18.2 中所有的依赖关系却都是从右向左跨越边界的，方向是由低层组件指向高层组件的。同时，我们也应该注意到，这一次数据结构的定义是位于调用方这一侧的。")])],-1),f=s("",43);function g(k,v,q,T,w,_){const t=r("Figures");return h(),c("div",null,[d,a(t,{figure:"18-1"},{default:n(()=>[o("Flow of control crosses the boundary from a lower level to a higher level")]),_:1}),m,u,b,y,a(t,{figure:"18-2"},{default:n(()=>[o("Crossing the boundary against the flow of control")]),_:1}),f])}const E=l(p,[["render",g]]);export{N as __pageData,E as default};
